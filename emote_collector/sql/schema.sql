-- Emote Collector collects emotes from other servers for use by people without Nitro
-- Copyright Â© 2019 lambda#0987
--
-- Emote Collector is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- Emote Collector is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with Emote Collector. If not, see <https://www.gnu.org/licenses/>.

SET TIME ZONE UTC;

--- EMOTES

CREATE TYPE nsfw AS ENUM ('SFW', 'SELF_NSFW', 'MOD_NSFW');

CREATE TABLE _guilds(
	id BIGINT PRIMARY KEY);

CREATE TABLE emotes(
	name VARCHAR(32) NOT NULL,
	id BIGINT PRIMARY KEY,
	author BIGINT NOT NULL,
	animated BOOLEAN NOT NULL DEFAULT FALSE,
	description VARCHAR(500),
	created TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	modified TIMESTAMP WITH TIME ZONE,
	preserve BOOLEAN NOT NULL DEFAULT FALSE,
	guild BIGINT NOT NULL REFERENCES _guilds ON DELETE CASCADE,
	nsfw nsfw NOT NULL DEFAULT 'SFW');

CREATE UNIQUE INDEX emotes_lower_idx ON emotes (LOWER(name));
CREATE INDEX emotes_name_trgm_idx ON emotes USING GIN (name gin_trgm_ops);
CREATE INDEX emotes_author_idx ON emotes (author);

CREATE VIEW guilds AS
	SELECT
		g.id,
		COUNT(e.guild) AS usage,
		COUNT(e.guild) FILTER (WHERE NOT e.animated) AS static_usage,
		COUNT(e.guild) FILTER (WHERE e.animated) AS animated_usage,
		MAX(e.created) AS last_creation
	FROM
		_guilds AS g
		LEFT JOIN emotes AS e
			ON e.guild = g.id
	GROUP BY g.id;

CREATE TYPE message_reply_type AS ENUM ('AUTO', 'QUOTE');

CREATE TABLE replies(
	invoking_message BIGINT PRIMARY KEY,
	type message_reply_type NOT NULL,
	reply_message BIGINT NOT NULL);

-- https://stackoverflow.com/a/26284695/1378440
CREATE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
	IF row(NEW.*) IS DISTINCT FROM row(OLD.*) THEN
		NEW.modified = CURRENT_TIMESTAMP;
	END IF;
	RETURN NEW; END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_emote_modtime
BEFORE UPDATE ON emotes
FOR EACH ROW EXECUTE PROCEDURE update_modified_column();

CREATE TABLE emote_usage_history(
	id BIGINT NOT NULL REFERENCES emotes ON DELETE CASCADE ON UPDATE CASCADE,
	time TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (CURRENT_TIMESTAMP));

CREATE INDEX emote_usage_history_id_idx ON emote_usage_history (id);
CREATE INDEX emote_usage_history_time_idx ON emote_usage_history (time);

--- OPTIONS / PLONKS

CREATE TABLE user_opt(
	id BIGINT PRIMARY KEY,
	state BOOLEAN,
	blacklist_reason TEXT);

CREATE TABLE guild_opt(
	id BIGINT PRIMARY KEY,
	state BOOLEAN,
	blacklist_reason TEXT);

CREATE INDEX blacklisted_guild_idx ON guild_opt (id) WHERE blacklist_reason IS NOT NULL;

CREATE TABLE api_tokens(
	id BIGINT PRIMARY KEY,
	secret BYTEA NOT NULL);

CREATE INDEX api_token_id_secret_idx ON api_tokens (id, secret);

CREATE TABLE locales(
	guild BIGINT,
	channel BIGINT,
	"user" BIGINT UNIQUE,
	locale VARCHAR(32) NOT NULL,

	CHECK (
		guild IS NOT NULL AND channel IS NULL AND "user" IS NULL
		OR guild IS NOT NULL AND channel IS NOT NULL
		OR channel IS NOT NULL
		OR "user" IS NOT NULL));

CREATE UNIQUE INDEX locales_guild_channel_uniq_index ON locales (channel, guild);

--- BINGO

CREATE TABLE bingo_boards(
	user_id BIGINT PRIMARY KEY,
	value INTEGER NOT NULL);

CREATE TABLE bingo_categories(
	category_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	category TEXT NOT NULL UNIQUE);

CREATE TABLE bingo_deleted_emotes(
	nsfw nsfw NOT NULL DEFAULT 'SFW',
	name VARCHAR(32) NOT NULL,
	deleted_emote_id BIGINT PRIMARY KEY,
	animated BOOLEAN NOT NULL DEFAULT FALSE);

CREATE TABLE bingo_board_marks(
	user_id BIGINT NOT NULL REFERENCES bingo_boards ON DELETE CASCADE,
	pos SMALLINT NOT NULL,
	emote_id BIGINT REFERENCES emotes,
	deleted_emote_id BIGINT REFERENCES bingo_deleted_emotes DEFERRABLE INITIALLY DEFERRED,

	CHECK (num_nonnulls(emote_id, deleted_emote_id) = 1),
	PRIMARY KEY (user_id, pos));

CREATE INDEX "bingo_board_marks_emote_id_idx" ON bingo_board_marks (emote_id);

CREATE FUNCTION bingo_archive_deleted_emote()
RETURNS TRIGGER AS $$ BEGIN
	IF (
		SELECT 1
		FROM bingo_board_marks
		WHERE emote_id = OLD.id
	) IS NOT NULL THEN
		INSERT INTO bingo_deleted_emotes (nsfw, name, deleted_emote_id, animated)
		VALUES (OLD.nsfw, OLD.name, OLD.id, OLD.animated);

		UPDATE bingo_board_marks
		SET
			deleted_emote_id = emote_id,
			emote_id = NULL
		WHERE emote_id = OLD.id;
	END IF;
	RETURN OLD;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER bingo_archive_deleted_emotes
BEFORE DELETE ON emotes
FOR EACH ROW EXECUTE PROCEDURE bingo_archive_deleted_emote();

CREATE TABLE bingo_board_categories(
	user_id BIGINT NOT NULL REFERENCES bingo_boards ON DELETE CASCADE,
	pos SMALLINT NOT NULL,
	category_id SMALLINT NOT NULL REFERENCES bingo_categories,

	PRIMARY KEY (user_id, pos));

CREATE PROCEDURE bingo_mark(
	p_user_id BIGINT,
	p_pos SMALLINT,
	p_nsfw nsfw,
	p_name VARCHAR(32),
	p_emote_id BIGINT,
	p_animated BOOLEAN
) LANGUAGE plpgsql AS $$ BEGIN
	IF (
		SELECT 1
		FROM emotes
		WHERE id = $5
	) IS NOT NULL THEN
		INSERT INTO bingo_board_marks (user_id, pos, emote_id)
		VALUES (p_user_id, p_pos, p_emote_id)
		ON CONFLICT (user_id, pos) DO UPDATE SET
			emote_id = EXCLUDED.emote_id,
			deleted_emote_id = NULL;
	ELSE
		INSERT INTO bingo_deleted_emotes (nsfw, name, deleted_emote_id, animated)
		VALUES (p_nsfw, p_name, p_emote_id, p_animated)
		ON CONFLICT (deleted_emote_id) DO UPDATE SET
			nsfw = EXCLUDED.nsfw,
			name = EXCLUDED.name,
			animated = EXCLUDED.animated;
		INSERT INTO bingo_board_marks (user_id, pos, deleted_emote_id)
		VALUES (p_user_id, p_pos, p_emote_id)
		ON CONFLICT (user_id, pos) DO UPDATE SET
			deleted_emote_id = EXCLUDED.deleted_emote_id,
			emote_id = NULL;
	END IF;
END; $$;
